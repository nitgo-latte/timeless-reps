# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateBreathingChain {
  _count: BreathingChainCountAggregate
  _max: BreathingChainMaxAggregate
  _min: BreathingChainMinAggregate
}

type AggregateExercise {
  _avg: ExerciseAvgAggregate
  _count: ExerciseCountAggregate
  _max: ExerciseMaxAggregate
  _min: ExerciseMinAggregate
  _sum: ExerciseSumAggregate
}

type AggregateExercisingSession {
  _avg: ExercisingSessionAvgAggregate
  _count: ExercisingSessionCountAggregate
  _max: ExercisingSessionMaxAggregate
  _min: ExercisingSessionMinAggregate
  _sum: ExercisingSessionSumAggregate
}

type AggregateMuscleGroup {
  _avg: MuscleGroupAvgAggregate
  _count: MuscleGroupCountAggregate
  _max: MuscleGroupMaxAggregate
  _min: MuscleGroupMinAggregate
  _sum: MuscleGroupSumAggregate
}

type AggregateTimeBox {
  _avg: TimeBoxAvgAggregate
  _count: TimeBoxCountAggregate
  _max: TimeBoxMaxAggregate
  _min: TimeBoxMinAggregate
  _sum: TimeBoxSumAggregate
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

type BreathingChain {
  _count: BreathingChainCount
  createdAt: DateTime!
  description: String!
  exercisingSessions(cursor: ExercisingSessionWhereUniqueInput, distinct: [ExercisingSessionScalarFieldEnum!], orderBy: [ExercisingSessionOrderByWithRelationInput!], skip: Int, take: Int, where: ExercisingSessionWhereInput): [ExercisingSession!]!
  id: String!
  updatedAt: DateTime!
}

type BreathingChainCount {
  exercisingSessions: Int!
}

type BreathingChainCountAggregate {
  _all: Int!
  createdAt: Int!
  description: Int!
  id: Int!
  updatedAt: Int!
}

input BreathingChainCountOrderByAggregateInput {
  description: SortOrder
  id: SortOrder
}

input BreathingChainCreateInput {
  description: String
  exercisingSessions: ExercisingSessionCreateNestedManyWithoutBreathingChainInput
  id: String
}

input BreathingChainCreateManyInput {
  description: String
  id: String
}

input BreathingChainCreateNestedOneWithoutExercisingSessionsInput {
  connect: BreathingChainWhereUniqueInput
  connectOrCreate: BreathingChainCreateOrConnectWithoutExercisingSessionsInput
  create: BreathingChainCreateWithoutExercisingSessionsInput
}

input BreathingChainCreateOrConnectWithoutExercisingSessionsInput {
  create: BreathingChainCreateWithoutExercisingSessionsInput!
  where: BreathingChainWhereUniqueInput!
}

input BreathingChainCreateWithoutExercisingSessionsInput {
  description: String
  id: String
}

type BreathingChainGroupBy {
  _count: BreathingChainCountAggregate
  _max: BreathingChainMaxAggregate
  _min: BreathingChainMinAggregate
  createdAt: DateTime!
  description: String!
  id: String!
  updatedAt: DateTime!
}

type BreathingChainMaxAggregate {
  createdAt: DateTime
  description: String
  id: String
  updatedAt: DateTime
}

input BreathingChainMaxOrderByAggregateInput {
  description: SortOrder
  id: SortOrder
}

type BreathingChainMinAggregate {
  createdAt: DateTime
  description: String
  id: String
  updatedAt: DateTime
}

input BreathingChainMinOrderByAggregateInput {
  description: SortOrder
  id: SortOrder
}

input BreathingChainOrderByWithAggregationInput {
  _count: BreathingChainCountOrderByAggregateInput
  _max: BreathingChainMaxOrderByAggregateInput
  _min: BreathingChainMinOrderByAggregateInput
  description: SortOrder
  id: SortOrder
}

input BreathingChainOrderByWithRelationInput {
  description: SortOrder
  exercisingSessions: ExercisingSessionOrderByRelationAggregateInput
  id: SortOrder
}

input BreathingChainRelationFilter {
  is: BreathingChainWhereInput
  isNot: BreathingChainWhereInput
}

enum BreathingChainScalarFieldEnum {
  createdAt
  description
  id
  updatedAt
}

input BreathingChainScalarWhereWithAggregatesInput {
  AND: [BreathingChainScalarWhereWithAggregatesInput!]
  NOT: [BreathingChainScalarWhereWithAggregatesInput!]
  OR: [BreathingChainScalarWhereWithAggregatesInput!]
  description: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
}

input BreathingChainUpdateInput {
  description: StringFieldUpdateOperationsInput
  exercisingSessions: ExercisingSessionUpdateManyWithoutBreathingChainNestedInput
  id: StringFieldUpdateOperationsInput
}

input BreathingChainUpdateManyMutationInput {
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
}

input BreathingChainUpdateOneWithoutExercisingSessionsNestedInput {
  connect: BreathingChainWhereUniqueInput
  connectOrCreate: BreathingChainCreateOrConnectWithoutExercisingSessionsInput
  create: BreathingChainCreateWithoutExercisingSessionsInput
  delete: Boolean
  disconnect: Boolean
  update: BreathingChainUpdateWithoutExercisingSessionsInput
  upsert: BreathingChainUpsertWithoutExercisingSessionsInput
}

input BreathingChainUpdateWithoutExercisingSessionsInput {
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
}

input BreathingChainUpsertWithoutExercisingSessionsInput {
  create: BreathingChainCreateWithoutExercisingSessionsInput!
  update: BreathingChainUpdateWithoutExercisingSessionsInput!
}

input BreathingChainWhereInput {
  AND: [BreathingChainWhereInput!]
  NOT: [BreathingChainWhereInput!]
  OR: [BreathingChainWhereInput!]
  description: StringFilter
  exercisingSessions: ExercisingSessionListRelationFilter
  id: StringFilter
}

input BreathingChainWhereUniqueInput {
  id: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

enum Difficulty {
  EASY
  HARD
  MEDIUM
}

input EnumDifficultyFieldUpdateOperationsInput {
  set: Difficulty
}

input EnumDifficultyFilter {
  equals: Difficulty
  in: [Difficulty!]
  not: NestedEnumDifficultyFilter
  notIn: [Difficulty!]
}

input EnumDifficultyWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumDifficultyFilter
  _min: NestedEnumDifficultyFilter
  equals: Difficulty
  in: [Difficulty!]
  not: NestedEnumDifficultyWithAggregatesFilter
  notIn: [Difficulty!]
}

type Exercise {
  ExercisingSession(cursor: ExercisingSessionWhereUniqueInput, distinct: [ExercisingSessionScalarFieldEnum!], orderBy: [ExercisingSessionOrderByWithRelationInput!], skip: Int, take: Int, where: ExercisingSessionWhereInput): [ExercisingSession!]!
  _count: ExerciseCount
  difficulty: Difficulty!
  id: Int!
  muscleGroups(cursor: MuscleGroupWhereUniqueInput, distinct: [MuscleGroupScalarFieldEnum!], orderBy: [MuscleGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MuscleGroupWhereInput): [MuscleGroup!]!
  name: String!
}

type ExerciseAvgAggregate {
  id: Float
}

input ExerciseAvgOrderByAggregateInput {
  id: SortOrder
}

type ExerciseCount {
  ExercisingSession: Int!
  muscleGroups: Int!
}

type ExerciseCountAggregate {
  _all: Int!
  difficulty: Int!
  id: Int!
  name: Int!
}

input ExerciseCountOrderByAggregateInput {
  difficulty: SortOrder
  id: SortOrder
  name: SortOrder
}

input ExerciseCreateInput {
  ExercisingSession: ExercisingSessionCreateNestedManyWithoutExerciseInput
  difficulty: Difficulty!
  muscleGroups: MuscleGroupCreateNestedManyWithoutExercisesInput
  name: String!
}

input ExerciseCreateManyInput {
  difficulty: Difficulty!
  id: Int
  name: String!
}

input ExerciseCreateNestedManyWithoutMuscleGroupsInput {
  connect: [ExerciseWhereUniqueInput!]
  connectOrCreate: [ExerciseCreateOrConnectWithoutMuscleGroupsInput!]
  create: [ExerciseCreateWithoutMuscleGroupsInput!]
}

input ExerciseCreateNestedOneWithoutExercisingSessionInput {
  connect: ExerciseWhereUniqueInput
  connectOrCreate: ExerciseCreateOrConnectWithoutExercisingSessionInput
  create: ExerciseCreateWithoutExercisingSessionInput
}

input ExerciseCreateOrConnectWithoutExercisingSessionInput {
  create: ExerciseCreateWithoutExercisingSessionInput!
  where: ExerciseWhereUniqueInput!
}

input ExerciseCreateOrConnectWithoutMuscleGroupsInput {
  create: ExerciseCreateWithoutMuscleGroupsInput!
  where: ExerciseWhereUniqueInput!
}

input ExerciseCreateWithoutExercisingSessionInput {
  difficulty: Difficulty!
  muscleGroups: MuscleGroupCreateNestedManyWithoutExercisesInput
  name: String!
}

input ExerciseCreateWithoutMuscleGroupsInput {
  ExercisingSession: ExercisingSessionCreateNestedManyWithoutExerciseInput
  difficulty: Difficulty!
  name: String!
}

type ExerciseGroupBy {
  _avg: ExerciseAvgAggregate
  _count: ExerciseCountAggregate
  _max: ExerciseMaxAggregate
  _min: ExerciseMinAggregate
  _sum: ExerciseSumAggregate
  difficulty: Difficulty!
  id: Int!
  name: String!
}

input ExerciseListRelationFilter {
  every: ExerciseWhereInput
  none: ExerciseWhereInput
  some: ExerciseWhereInput
}

type ExerciseMaxAggregate {
  difficulty: Difficulty
  id: Int
  name: String
}

input ExerciseMaxOrderByAggregateInput {
  difficulty: SortOrder
  id: SortOrder
  name: SortOrder
}

type ExerciseMinAggregate {
  difficulty: Difficulty
  id: Int
  name: String
}

input ExerciseMinOrderByAggregateInput {
  difficulty: SortOrder
  id: SortOrder
  name: SortOrder
}

input ExerciseOrderByRelationAggregateInput {
  _count: SortOrder
}

input ExerciseOrderByWithAggregationInput {
  _avg: ExerciseAvgOrderByAggregateInput
  _count: ExerciseCountOrderByAggregateInput
  _max: ExerciseMaxOrderByAggregateInput
  _min: ExerciseMinOrderByAggregateInput
  _sum: ExerciseSumOrderByAggregateInput
  difficulty: SortOrder
  id: SortOrder
  name: SortOrder
}

input ExerciseOrderByWithRelationInput {
  ExercisingSession: ExercisingSessionOrderByRelationAggregateInput
  difficulty: SortOrder
  id: SortOrder
  muscleGroups: MuscleGroupOrderByRelationAggregateInput
  name: SortOrder
}

input ExerciseRelationFilter {
  is: ExerciseWhereInput
  isNot: ExerciseWhereInput
}

enum ExerciseScalarFieldEnum {
  difficulty
  id
  name
}

input ExerciseScalarWhereInput {
  AND: [ExerciseScalarWhereInput!]
  NOT: [ExerciseScalarWhereInput!]
  OR: [ExerciseScalarWhereInput!]
  difficulty: EnumDifficultyFilter
  id: IntFilter
  name: StringFilter
}

input ExerciseScalarWhereWithAggregatesInput {
  AND: [ExerciseScalarWhereWithAggregatesInput!]
  NOT: [ExerciseScalarWhereWithAggregatesInput!]
  OR: [ExerciseScalarWhereWithAggregatesInput!]
  difficulty: EnumDifficultyWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type ExerciseSumAggregate {
  id: Int
}

input ExerciseSumOrderByAggregateInput {
  id: SortOrder
}

input ExerciseUpdateInput {
  ExercisingSession: ExercisingSessionUpdateManyWithoutExerciseNestedInput
  difficulty: EnumDifficultyFieldUpdateOperationsInput
  muscleGroups: MuscleGroupUpdateManyWithoutExercisesNestedInput
  name: StringFieldUpdateOperationsInput
}

input ExerciseUpdateManyMutationInput {
  difficulty: EnumDifficultyFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ExerciseUpdateManyWithWhereWithoutMuscleGroupsInput {
  data: ExerciseUpdateManyMutationInput!
  where: ExerciseScalarWhereInput!
}

input ExerciseUpdateManyWithoutMuscleGroupsNestedInput {
  connect: [ExerciseWhereUniqueInput!]
  connectOrCreate: [ExerciseCreateOrConnectWithoutMuscleGroupsInput!]
  create: [ExerciseCreateWithoutMuscleGroupsInput!]
  delete: [ExerciseWhereUniqueInput!]
  deleteMany: [ExerciseScalarWhereInput!]
  disconnect: [ExerciseWhereUniqueInput!]
  set: [ExerciseWhereUniqueInput!]
  update: [ExerciseUpdateWithWhereUniqueWithoutMuscleGroupsInput!]
  updateMany: [ExerciseUpdateManyWithWhereWithoutMuscleGroupsInput!]
  upsert: [ExerciseUpsertWithWhereUniqueWithoutMuscleGroupsInput!]
}

input ExerciseUpdateOneWithoutExercisingSessionNestedInput {
  connect: ExerciseWhereUniqueInput
  connectOrCreate: ExerciseCreateOrConnectWithoutExercisingSessionInput
  create: ExerciseCreateWithoutExercisingSessionInput
  delete: Boolean
  disconnect: Boolean
  update: ExerciseUpdateWithoutExercisingSessionInput
  upsert: ExerciseUpsertWithoutExercisingSessionInput
}

input ExerciseUpdateWithWhereUniqueWithoutMuscleGroupsInput {
  data: ExerciseUpdateWithoutMuscleGroupsInput!
  where: ExerciseWhereUniqueInput!
}

input ExerciseUpdateWithoutExercisingSessionInput {
  difficulty: EnumDifficultyFieldUpdateOperationsInput
  muscleGroups: MuscleGroupUpdateManyWithoutExercisesNestedInput
  name: StringFieldUpdateOperationsInput
}

input ExerciseUpdateWithoutMuscleGroupsInput {
  ExercisingSession: ExercisingSessionUpdateManyWithoutExerciseNestedInput
  difficulty: EnumDifficultyFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ExerciseUpsertWithWhereUniqueWithoutMuscleGroupsInput {
  create: ExerciseCreateWithoutMuscleGroupsInput!
  update: ExerciseUpdateWithoutMuscleGroupsInput!
  where: ExerciseWhereUniqueInput!
}

input ExerciseUpsertWithoutExercisingSessionInput {
  create: ExerciseCreateWithoutExercisingSessionInput!
  update: ExerciseUpdateWithoutExercisingSessionInput!
}

input ExerciseWhereInput {
  AND: [ExerciseWhereInput!]
  ExercisingSession: ExercisingSessionListRelationFilter
  NOT: [ExerciseWhereInput!]
  OR: [ExerciseWhereInput!]
  difficulty: EnumDifficultyFilter
  id: IntFilter
  muscleGroups: MuscleGroupListRelationFilter
  name: StringFilter
}

input ExerciseWhereUniqueInput {
  id: Int
  name: String
}

type ExercisingSession {
  BreathingChain: BreathingChain
  TimeBox(cursor: TimeBoxWhereUniqueInput, distinct: [TimeBoxScalarFieldEnum!], orderBy: [TimeBoxOrderByWithRelationInput!], skip: Int, take: Int, where: TimeBoxWhereInput): [TimeBox!]!
  _count: ExercisingSessionCount
  breathingChainId: String!
  exercise: Exercise
  exerciseId: Int!
  id: Int!
  message: String
}

type ExercisingSessionAvgAggregate {
  exerciseId: Float
  id: Float
}

input ExercisingSessionAvgOrderByAggregateInput {
  exerciseId: SortOrder
  id: SortOrder
}

type ExercisingSessionCount {
  TimeBox: Int!
}

type ExercisingSessionCountAggregate {
  _all: Int!
  breathingChainId: Int!
  exerciseId: Int!
  id: Int!
  message: Int!
}

input ExercisingSessionCountOrderByAggregateInput {
  breathingChainId: SortOrder
  exerciseId: SortOrder
  id: SortOrder
  message: SortOrder
}

input ExercisingSessionCreateInput {
  BreathingChain: BreathingChainCreateNestedOneWithoutExercisingSessionsInput
  TimeBox: TimeBoxCreateNestedManyWithoutExercisingSessionInput
  exercise: ExerciseCreateNestedOneWithoutExercisingSessionInput
  message: String
}

input ExercisingSessionCreateManyBreathingChainInput {
  exerciseId: Int!
  id: Int
  message: String
}

input ExercisingSessionCreateManyBreathingChainInputEnvelope {
  data: [ExercisingSessionCreateManyBreathingChainInput!]!
  skipDuplicates: Boolean
}

input ExercisingSessionCreateManyExerciseInput {
  breathingChainId: String!
  id: Int
  message: String
}

input ExercisingSessionCreateManyExerciseInputEnvelope {
  data: [ExercisingSessionCreateManyExerciseInput!]!
  skipDuplicates: Boolean
}

input ExercisingSessionCreateManyInput {
  breathingChainId: String!
  exerciseId: Int!
  id: Int
  message: String
}

input ExercisingSessionCreateNestedManyWithoutBreathingChainInput {
  connect: [ExercisingSessionWhereUniqueInput!]
  connectOrCreate: [ExercisingSessionCreateOrConnectWithoutBreathingChainInput!]
  create: [ExercisingSessionCreateWithoutBreathingChainInput!]
  createMany: ExercisingSessionCreateManyBreathingChainInputEnvelope
}

input ExercisingSessionCreateNestedManyWithoutExerciseInput {
  connect: [ExercisingSessionWhereUniqueInput!]
  connectOrCreate: [ExercisingSessionCreateOrConnectWithoutExerciseInput!]
  create: [ExercisingSessionCreateWithoutExerciseInput!]
  createMany: ExercisingSessionCreateManyExerciseInputEnvelope
}

input ExercisingSessionCreateNestedOneWithoutTimeBoxInput {
  connect: ExercisingSessionWhereUniqueInput
  connectOrCreate: ExercisingSessionCreateOrConnectWithoutTimeBoxInput
  create: ExercisingSessionCreateWithoutTimeBoxInput
}

input ExercisingSessionCreateOrConnectWithoutBreathingChainInput {
  create: ExercisingSessionCreateWithoutBreathingChainInput!
  where: ExercisingSessionWhereUniqueInput!
}

input ExercisingSessionCreateOrConnectWithoutExerciseInput {
  create: ExercisingSessionCreateWithoutExerciseInput!
  where: ExercisingSessionWhereUniqueInput!
}

input ExercisingSessionCreateOrConnectWithoutTimeBoxInput {
  create: ExercisingSessionCreateWithoutTimeBoxInput!
  where: ExercisingSessionWhereUniqueInput!
}

input ExercisingSessionCreateWithoutBreathingChainInput {
  TimeBox: TimeBoxCreateNestedManyWithoutExercisingSessionInput
  exercise: ExerciseCreateNestedOneWithoutExercisingSessionInput
  message: String
}

input ExercisingSessionCreateWithoutExerciseInput {
  BreathingChain: BreathingChainCreateNestedOneWithoutExercisingSessionsInput
  TimeBox: TimeBoxCreateNestedManyWithoutExercisingSessionInput
  message: String
}

input ExercisingSessionCreateWithoutTimeBoxInput {
  BreathingChain: BreathingChainCreateNestedOneWithoutExercisingSessionsInput
  exercise: ExerciseCreateNestedOneWithoutExercisingSessionInput
  message: String
}

input ExercisingSessionExerciseIdBreathingChainIdCompoundUniqueInput {
  breathingChainId: String!
  exerciseId: Int!
}

type ExercisingSessionGroupBy {
  _avg: ExercisingSessionAvgAggregate
  _count: ExercisingSessionCountAggregate
  _max: ExercisingSessionMaxAggregate
  _min: ExercisingSessionMinAggregate
  _sum: ExercisingSessionSumAggregate
  breathingChainId: String!
  exerciseId: Int!
  id: Int!
  message: String
}

input ExercisingSessionListRelationFilter {
  every: ExercisingSessionWhereInput
  none: ExercisingSessionWhereInput
  some: ExercisingSessionWhereInput
}

type ExercisingSessionMaxAggregate {
  breathingChainId: String
  exerciseId: Int
  id: Int
  message: String
}

input ExercisingSessionMaxOrderByAggregateInput {
  breathingChainId: SortOrder
  exerciseId: SortOrder
  id: SortOrder
  message: SortOrder
}

type ExercisingSessionMinAggregate {
  breathingChainId: String
  exerciseId: Int
  id: Int
  message: String
}

input ExercisingSessionMinOrderByAggregateInput {
  breathingChainId: SortOrder
  exerciseId: SortOrder
  id: SortOrder
  message: SortOrder
}

input ExercisingSessionOrderByRelationAggregateInput {
  _count: SortOrder
}

input ExercisingSessionOrderByWithAggregationInput {
  _avg: ExercisingSessionAvgOrderByAggregateInput
  _count: ExercisingSessionCountOrderByAggregateInput
  _max: ExercisingSessionMaxOrderByAggregateInput
  _min: ExercisingSessionMinOrderByAggregateInput
  _sum: ExercisingSessionSumOrderByAggregateInput
  breathingChainId: SortOrder
  exerciseId: SortOrder
  id: SortOrder
  message: SortOrder
}

input ExercisingSessionOrderByWithRelationInput {
  BreathingChain: BreathingChainOrderByWithRelationInput
  TimeBox: TimeBoxOrderByRelationAggregateInput
  breathingChainId: SortOrder
  exercise: ExerciseOrderByWithRelationInput
  exerciseId: SortOrder
  id: SortOrder
  message: SortOrder
}

input ExercisingSessionRelationFilter {
  is: ExercisingSessionWhereInput
  isNot: ExercisingSessionWhereInput
}

enum ExercisingSessionScalarFieldEnum {
  breathingChainId
  exerciseId
  id
  message
}

input ExercisingSessionScalarWhereInput {
  AND: [ExercisingSessionScalarWhereInput!]
  NOT: [ExercisingSessionScalarWhereInput!]
  OR: [ExercisingSessionScalarWhereInput!]
  breathingChainId: StringFilter
  exerciseId: IntFilter
  id: IntFilter
  message: StringNullableFilter
}

input ExercisingSessionScalarWhereWithAggregatesInput {
  AND: [ExercisingSessionScalarWhereWithAggregatesInput!]
  NOT: [ExercisingSessionScalarWhereWithAggregatesInput!]
  OR: [ExercisingSessionScalarWhereWithAggregatesInput!]
  breathingChainId: StringWithAggregatesFilter
  exerciseId: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  message: StringNullableWithAggregatesFilter
}

type ExercisingSessionSumAggregate {
  exerciseId: Int
  id: Int
}

input ExercisingSessionSumOrderByAggregateInput {
  exerciseId: SortOrder
  id: SortOrder
}

input ExercisingSessionUpdateInput {
  BreathingChain: BreathingChainUpdateOneWithoutExercisingSessionsNestedInput
  TimeBox: TimeBoxUpdateManyWithoutExercisingSessionNestedInput
  exercise: ExerciseUpdateOneWithoutExercisingSessionNestedInput
  message: NullableStringFieldUpdateOperationsInput
}

input ExercisingSessionUpdateManyMutationInput {
  message: NullableStringFieldUpdateOperationsInput
}

input ExercisingSessionUpdateManyWithWhereWithoutBreathingChainInput {
  data: ExercisingSessionUpdateManyMutationInput!
  where: ExercisingSessionScalarWhereInput!
}

input ExercisingSessionUpdateManyWithWhereWithoutExerciseInput {
  data: ExercisingSessionUpdateManyMutationInput!
  where: ExercisingSessionScalarWhereInput!
}

input ExercisingSessionUpdateManyWithoutBreathingChainNestedInput {
  connect: [ExercisingSessionWhereUniqueInput!]
  connectOrCreate: [ExercisingSessionCreateOrConnectWithoutBreathingChainInput!]
  create: [ExercisingSessionCreateWithoutBreathingChainInput!]
  createMany: ExercisingSessionCreateManyBreathingChainInputEnvelope
  delete: [ExercisingSessionWhereUniqueInput!]
  deleteMany: [ExercisingSessionScalarWhereInput!]
  disconnect: [ExercisingSessionWhereUniqueInput!]
  set: [ExercisingSessionWhereUniqueInput!]
  update: [ExercisingSessionUpdateWithWhereUniqueWithoutBreathingChainInput!]
  updateMany: [ExercisingSessionUpdateManyWithWhereWithoutBreathingChainInput!]
  upsert: [ExercisingSessionUpsertWithWhereUniqueWithoutBreathingChainInput!]
}

input ExercisingSessionUpdateManyWithoutExerciseNestedInput {
  connect: [ExercisingSessionWhereUniqueInput!]
  connectOrCreate: [ExercisingSessionCreateOrConnectWithoutExerciseInput!]
  create: [ExercisingSessionCreateWithoutExerciseInput!]
  createMany: ExercisingSessionCreateManyExerciseInputEnvelope
  delete: [ExercisingSessionWhereUniqueInput!]
  deleteMany: [ExercisingSessionScalarWhereInput!]
  disconnect: [ExercisingSessionWhereUniqueInput!]
  set: [ExercisingSessionWhereUniqueInput!]
  update: [ExercisingSessionUpdateWithWhereUniqueWithoutExerciseInput!]
  updateMany: [ExercisingSessionUpdateManyWithWhereWithoutExerciseInput!]
  upsert: [ExercisingSessionUpsertWithWhereUniqueWithoutExerciseInput!]
}

input ExercisingSessionUpdateOneRequiredWithoutTimeBoxNestedInput {
  connect: ExercisingSessionWhereUniqueInput
  connectOrCreate: ExercisingSessionCreateOrConnectWithoutTimeBoxInput
  create: ExercisingSessionCreateWithoutTimeBoxInput
  update: ExercisingSessionUpdateWithoutTimeBoxInput
  upsert: ExercisingSessionUpsertWithoutTimeBoxInput
}

input ExercisingSessionUpdateWithWhereUniqueWithoutBreathingChainInput {
  data: ExercisingSessionUpdateWithoutBreathingChainInput!
  where: ExercisingSessionWhereUniqueInput!
}

input ExercisingSessionUpdateWithWhereUniqueWithoutExerciseInput {
  data: ExercisingSessionUpdateWithoutExerciseInput!
  where: ExercisingSessionWhereUniqueInput!
}

input ExercisingSessionUpdateWithoutBreathingChainInput {
  TimeBox: TimeBoxUpdateManyWithoutExercisingSessionNestedInput
  exercise: ExerciseUpdateOneWithoutExercisingSessionNestedInput
  message: NullableStringFieldUpdateOperationsInput
}

input ExercisingSessionUpdateWithoutExerciseInput {
  BreathingChain: BreathingChainUpdateOneWithoutExercisingSessionsNestedInput
  TimeBox: TimeBoxUpdateManyWithoutExercisingSessionNestedInput
  message: NullableStringFieldUpdateOperationsInput
}

input ExercisingSessionUpdateWithoutTimeBoxInput {
  BreathingChain: BreathingChainUpdateOneWithoutExercisingSessionsNestedInput
  exercise: ExerciseUpdateOneWithoutExercisingSessionNestedInput
  message: NullableStringFieldUpdateOperationsInput
}

input ExercisingSessionUpsertWithWhereUniqueWithoutBreathingChainInput {
  create: ExercisingSessionCreateWithoutBreathingChainInput!
  update: ExercisingSessionUpdateWithoutBreathingChainInput!
  where: ExercisingSessionWhereUniqueInput!
}

input ExercisingSessionUpsertWithWhereUniqueWithoutExerciseInput {
  create: ExercisingSessionCreateWithoutExerciseInput!
  update: ExercisingSessionUpdateWithoutExerciseInput!
  where: ExercisingSessionWhereUniqueInput!
}

input ExercisingSessionUpsertWithoutTimeBoxInput {
  create: ExercisingSessionCreateWithoutTimeBoxInput!
  update: ExercisingSessionUpdateWithoutTimeBoxInput!
}

input ExercisingSessionWhereInput {
  AND: [ExercisingSessionWhereInput!]
  BreathingChain: BreathingChainRelationFilter
  NOT: [ExercisingSessionWhereInput!]
  OR: [ExercisingSessionWhereInput!]
  TimeBox: TimeBoxListRelationFilter
  breathingChainId: StringFilter
  exercise: ExerciseRelationFilter
  exerciseId: IntFilter
  id: IntFilter
  message: StringNullableFilter
}

input ExercisingSessionWhereUniqueInput {
  exerciseId_breathingChainId: ExercisingSessionExerciseIdBreathingChainIdCompoundUniqueInput
  id: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type MuscleGroup {
  _count: MuscleGroupCount
  exercises(cursor: ExerciseWhereUniqueInput, distinct: [ExerciseScalarFieldEnum!], orderBy: [ExerciseOrderByWithRelationInput!], skip: Int, take: Int, where: ExerciseWhereInput): [Exercise!]!
  id: Int!
  name: String!
}

type MuscleGroupAvgAggregate {
  id: Float
}

input MuscleGroupAvgOrderByAggregateInput {
  id: SortOrder
}

type MuscleGroupCount {
  exercises: Int!
}

type MuscleGroupCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
}

input MuscleGroupCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input MuscleGroupCreateInput {
  exercises: ExerciseCreateNestedManyWithoutMuscleGroupsInput
  name: String!
}

input MuscleGroupCreateManyInput {
  id: Int
  name: String!
}

input MuscleGroupCreateNestedManyWithoutExercisesInput {
  connect: [MuscleGroupWhereUniqueInput!]
  connectOrCreate: [MuscleGroupCreateOrConnectWithoutExercisesInput!]
  create: [MuscleGroupCreateWithoutExercisesInput!]
}

input MuscleGroupCreateOrConnectWithoutExercisesInput {
  create: MuscleGroupCreateWithoutExercisesInput!
  where: MuscleGroupWhereUniqueInput!
}

input MuscleGroupCreateWithoutExercisesInput {
  name: String!
}

type MuscleGroupGroupBy {
  _avg: MuscleGroupAvgAggregate
  _count: MuscleGroupCountAggregate
  _max: MuscleGroupMaxAggregate
  _min: MuscleGroupMinAggregate
  _sum: MuscleGroupSumAggregate
  id: Int!
  name: String!
}

input MuscleGroupListRelationFilter {
  every: MuscleGroupWhereInput
  none: MuscleGroupWhereInput
  some: MuscleGroupWhereInput
}

type MuscleGroupMaxAggregate {
  id: Int
  name: String
}

input MuscleGroupMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type MuscleGroupMinAggregate {
  id: Int
  name: String
}

input MuscleGroupMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input MuscleGroupOrderByRelationAggregateInput {
  _count: SortOrder
}

input MuscleGroupOrderByWithAggregationInput {
  _avg: MuscleGroupAvgOrderByAggregateInput
  _count: MuscleGroupCountOrderByAggregateInput
  _max: MuscleGroupMaxOrderByAggregateInput
  _min: MuscleGroupMinOrderByAggregateInput
  _sum: MuscleGroupSumOrderByAggregateInput
  id: SortOrder
  name: SortOrder
}

input MuscleGroupOrderByWithRelationInput {
  exercises: ExerciseOrderByRelationAggregateInput
  id: SortOrder
  name: SortOrder
}

enum MuscleGroupScalarFieldEnum {
  id
  name
}

input MuscleGroupScalarWhereInput {
  AND: [MuscleGroupScalarWhereInput!]
  NOT: [MuscleGroupScalarWhereInput!]
  OR: [MuscleGroupScalarWhereInput!]
  id: IntFilter
  name: StringFilter
}

input MuscleGroupScalarWhereWithAggregatesInput {
  AND: [MuscleGroupScalarWhereWithAggregatesInput!]
  NOT: [MuscleGroupScalarWhereWithAggregatesInput!]
  OR: [MuscleGroupScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type MuscleGroupSumAggregate {
  id: Int
}

input MuscleGroupSumOrderByAggregateInput {
  id: SortOrder
}

input MuscleGroupUpdateInput {
  exercises: ExerciseUpdateManyWithoutMuscleGroupsNestedInput
  name: StringFieldUpdateOperationsInput
}

input MuscleGroupUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
}

input MuscleGroupUpdateManyWithWhereWithoutExercisesInput {
  data: MuscleGroupUpdateManyMutationInput!
  where: MuscleGroupScalarWhereInput!
}

input MuscleGroupUpdateManyWithoutExercisesNestedInput {
  connect: [MuscleGroupWhereUniqueInput!]
  connectOrCreate: [MuscleGroupCreateOrConnectWithoutExercisesInput!]
  create: [MuscleGroupCreateWithoutExercisesInput!]
  delete: [MuscleGroupWhereUniqueInput!]
  deleteMany: [MuscleGroupScalarWhereInput!]
  disconnect: [MuscleGroupWhereUniqueInput!]
  set: [MuscleGroupWhereUniqueInput!]
  update: [MuscleGroupUpdateWithWhereUniqueWithoutExercisesInput!]
  updateMany: [MuscleGroupUpdateManyWithWhereWithoutExercisesInput!]
  upsert: [MuscleGroupUpsertWithWhereUniqueWithoutExercisesInput!]
}

input MuscleGroupUpdateWithWhereUniqueWithoutExercisesInput {
  data: MuscleGroupUpdateWithoutExercisesInput!
  where: MuscleGroupWhereUniqueInput!
}

input MuscleGroupUpdateWithoutExercisesInput {
  name: StringFieldUpdateOperationsInput
}

input MuscleGroupUpsertWithWhereUniqueWithoutExercisesInput {
  create: MuscleGroupCreateWithoutExercisesInput!
  update: MuscleGroupUpdateWithoutExercisesInput!
  where: MuscleGroupWhereUniqueInput!
}

input MuscleGroupWhereInput {
  AND: [MuscleGroupWhereInput!]
  NOT: [MuscleGroupWhereInput!]
  OR: [MuscleGroupWhereInput!]
  exercises: ExerciseListRelationFilter
  id: IntFilter
  name: StringFilter
}

input MuscleGroupWhereUniqueInput {
  id: Int
  name: String
}

type Mutation {
  createManyBreathingChain(data: [BreathingChainCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyExercise(data: [ExerciseCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyExercisingSession(data: [ExercisingSessionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyMuscleGroup(data: [MuscleGroupCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyTimeBox(data: [TimeBoxCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneBreathingChain(data: BreathingChainCreateInput!): BreathingChain!
  createOneExercise(data: ExerciseCreateInput!): Exercise!
  createOneExercisingSession(data: ExercisingSessionCreateInput!): ExercisingSession!
  createOneMuscleGroup(data: MuscleGroupCreateInput!): MuscleGroup!
  createOneTimeBox(data: TimeBoxCreateInput!): TimeBox!
  deleteManyBreathingChain(where: BreathingChainWhereInput): AffectedRowsOutput!
  deleteManyExercise(where: ExerciseWhereInput): AffectedRowsOutput!
  deleteManyExercisingSession(where: ExercisingSessionWhereInput): AffectedRowsOutput!
  deleteManyMuscleGroup(where: MuscleGroupWhereInput): AffectedRowsOutput!
  deleteManyTimeBox(where: TimeBoxWhereInput): AffectedRowsOutput!
  deleteOneBreathingChain(where: BreathingChainWhereUniqueInput!): BreathingChain
  deleteOneExercise(where: ExerciseWhereUniqueInput!): Exercise
  deleteOneExercisingSession(where: ExercisingSessionWhereUniqueInput!): ExercisingSession
  deleteOneMuscleGroup(where: MuscleGroupWhereUniqueInput!): MuscleGroup
  deleteOneTimeBox(where: TimeBoxWhereUniqueInput!): TimeBox
  updateManyBreathingChain(data: BreathingChainUpdateManyMutationInput!, where: BreathingChainWhereInput): AffectedRowsOutput!
  updateManyExercise(data: ExerciseUpdateManyMutationInput!, where: ExerciseWhereInput): AffectedRowsOutput!
  updateManyExercisingSession(data: ExercisingSessionUpdateManyMutationInput!, where: ExercisingSessionWhereInput): AffectedRowsOutput!
  updateManyMuscleGroup(data: MuscleGroupUpdateManyMutationInput!, where: MuscleGroupWhereInput): AffectedRowsOutput!
  updateManyTimeBox(data: TimeBoxUpdateManyMutationInput!, where: TimeBoxWhereInput): AffectedRowsOutput!
  updateOneBreathingChain(data: BreathingChainUpdateInput!, where: BreathingChainWhereUniqueInput!): BreathingChain
  updateOneExercise(data: ExerciseUpdateInput!, where: ExerciseWhereUniqueInput!): Exercise
  updateOneExercisingSession(data: ExercisingSessionUpdateInput!, where: ExercisingSessionWhereUniqueInput!): ExercisingSession
  updateOneMuscleGroup(data: MuscleGroupUpdateInput!, where: MuscleGroupWhereUniqueInput!): MuscleGroup
  updateOneTimeBox(data: TimeBoxUpdateInput!, where: TimeBoxWhereUniqueInput!): TimeBox
  upsertOneBreathingChain(create: BreathingChainCreateInput!, update: BreathingChainUpdateInput!, where: BreathingChainWhereUniqueInput!): BreathingChain!
  upsertOneExercise(create: ExerciseCreateInput!, update: ExerciseUpdateInput!, where: ExerciseWhereUniqueInput!): Exercise!
  upsertOneExercisingSession(create: ExercisingSessionCreateInput!, update: ExercisingSessionUpdateInput!, where: ExercisingSessionWhereUniqueInput!): ExercisingSession!
  upsertOneMuscleGroup(create: MuscleGroupCreateInput!, update: MuscleGroupUpdateInput!, where: MuscleGroupWhereUniqueInput!): MuscleGroup!
  upsertOneTimeBox(create: TimeBoxCreateInput!, update: TimeBoxUpdateInput!, where: TimeBoxWhereUniqueInput!): TimeBox!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumDifficultyFilter {
  equals: Difficulty
  in: [Difficulty!]
  not: NestedEnumDifficultyFilter
  notIn: [Difficulty!]
}

input NestedEnumDifficultyWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumDifficultyFilter
  _min: NestedEnumDifficultyFilter
  equals: Difficulty
  in: [Difficulty!]
  not: NestedEnumDifficultyWithAggregatesFilter
  notIn: [Difficulty!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  aggregateBreathingChain(cursor: BreathingChainWhereUniqueInput, orderBy: [BreathingChainOrderByWithRelationInput!], skip: Int, take: Int, where: BreathingChainWhereInput): AggregateBreathingChain!
  aggregateExercise(cursor: ExerciseWhereUniqueInput, orderBy: [ExerciseOrderByWithRelationInput!], skip: Int, take: Int, where: ExerciseWhereInput): AggregateExercise!
  aggregateExercisingSession(cursor: ExercisingSessionWhereUniqueInput, orderBy: [ExercisingSessionOrderByWithRelationInput!], skip: Int, take: Int, where: ExercisingSessionWhereInput): AggregateExercisingSession!
  aggregateMuscleGroup(cursor: MuscleGroupWhereUniqueInput, orderBy: [MuscleGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MuscleGroupWhereInput): AggregateMuscleGroup!
  aggregateTimeBox(cursor: TimeBoxWhereUniqueInput, orderBy: [TimeBoxOrderByWithRelationInput!], skip: Int, take: Int, where: TimeBoxWhereInput): AggregateTimeBox!
  breathingChain(where: BreathingChainWhereUniqueInput!): BreathingChain
  breathingChains(cursor: BreathingChainWhereUniqueInput, distinct: [BreathingChainScalarFieldEnum!], orderBy: [BreathingChainOrderByWithRelationInput!], skip: Int, take: Int, where: BreathingChainWhereInput): [BreathingChain!]!
  exercise(where: ExerciseWhereUniqueInput!): Exercise
  exercises(cursor: ExerciseWhereUniqueInput, distinct: [ExerciseScalarFieldEnum!], orderBy: [ExerciseOrderByWithRelationInput!], skip: Int, take: Int, where: ExerciseWhereInput): [Exercise!]!
  exercisingSession(where: ExercisingSessionWhereUniqueInput!): ExercisingSession
  exercisingSessions(cursor: ExercisingSessionWhereUniqueInput, distinct: [ExercisingSessionScalarFieldEnum!], orderBy: [ExercisingSessionOrderByWithRelationInput!], skip: Int, take: Int, where: ExercisingSessionWhereInput): [ExercisingSession!]!
  findFirstBreathingChain(cursor: BreathingChainWhereUniqueInput, distinct: [BreathingChainScalarFieldEnum!], orderBy: [BreathingChainOrderByWithRelationInput!], skip: Int, take: Int, where: BreathingChainWhereInput): BreathingChain
  findFirstBreathingChainOrThrow(cursor: BreathingChainWhereUniqueInput, distinct: [BreathingChainScalarFieldEnum!], orderBy: [BreathingChainOrderByWithRelationInput!], skip: Int, take: Int, where: BreathingChainWhereInput): BreathingChain
  findFirstExercise(cursor: ExerciseWhereUniqueInput, distinct: [ExerciseScalarFieldEnum!], orderBy: [ExerciseOrderByWithRelationInput!], skip: Int, take: Int, where: ExerciseWhereInput): Exercise
  findFirstExerciseOrThrow(cursor: ExerciseWhereUniqueInput, distinct: [ExerciseScalarFieldEnum!], orderBy: [ExerciseOrderByWithRelationInput!], skip: Int, take: Int, where: ExerciseWhereInput): Exercise
  findFirstExercisingSession(cursor: ExercisingSessionWhereUniqueInput, distinct: [ExercisingSessionScalarFieldEnum!], orderBy: [ExercisingSessionOrderByWithRelationInput!], skip: Int, take: Int, where: ExercisingSessionWhereInput): ExercisingSession
  findFirstExercisingSessionOrThrow(cursor: ExercisingSessionWhereUniqueInput, distinct: [ExercisingSessionScalarFieldEnum!], orderBy: [ExercisingSessionOrderByWithRelationInput!], skip: Int, take: Int, where: ExercisingSessionWhereInput): ExercisingSession
  findFirstMuscleGroup(cursor: MuscleGroupWhereUniqueInput, distinct: [MuscleGroupScalarFieldEnum!], orderBy: [MuscleGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MuscleGroupWhereInput): MuscleGroup
  findFirstMuscleGroupOrThrow(cursor: MuscleGroupWhereUniqueInput, distinct: [MuscleGroupScalarFieldEnum!], orderBy: [MuscleGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MuscleGroupWhereInput): MuscleGroup
  findFirstTimeBox(cursor: TimeBoxWhereUniqueInput, distinct: [TimeBoxScalarFieldEnum!], orderBy: [TimeBoxOrderByWithRelationInput!], skip: Int, take: Int, where: TimeBoxWhereInput): TimeBox
  findFirstTimeBoxOrThrow(cursor: TimeBoxWhereUniqueInput, distinct: [TimeBoxScalarFieldEnum!], orderBy: [TimeBoxOrderByWithRelationInput!], skip: Int, take: Int, where: TimeBoxWhereInput): TimeBox
  getBreathingChain(where: BreathingChainWhereUniqueInput!): BreathingChain
  getExercise(where: ExerciseWhereUniqueInput!): Exercise
  getExercisingSession(where: ExercisingSessionWhereUniqueInput!): ExercisingSession
  getMuscleGroup(where: MuscleGroupWhereUniqueInput!): MuscleGroup
  getTimeBox(where: TimeBoxWhereUniqueInput!): TimeBox
  groupByBreathingChain(by: [BreathingChainScalarFieldEnum!]!, having: BreathingChainScalarWhereWithAggregatesInput, orderBy: [BreathingChainOrderByWithAggregationInput!], skip: Int, take: Int, where: BreathingChainWhereInput): [BreathingChainGroupBy!]!
  groupByExercise(by: [ExerciseScalarFieldEnum!]!, having: ExerciseScalarWhereWithAggregatesInput, orderBy: [ExerciseOrderByWithAggregationInput!], skip: Int, take: Int, where: ExerciseWhereInput): [ExerciseGroupBy!]!
  groupByExercisingSession(by: [ExercisingSessionScalarFieldEnum!]!, having: ExercisingSessionScalarWhereWithAggregatesInput, orderBy: [ExercisingSessionOrderByWithAggregationInput!], skip: Int, take: Int, where: ExercisingSessionWhereInput): [ExercisingSessionGroupBy!]!
  groupByMuscleGroup(by: [MuscleGroupScalarFieldEnum!]!, having: MuscleGroupScalarWhereWithAggregatesInput, orderBy: [MuscleGroupOrderByWithAggregationInput!], skip: Int, take: Int, where: MuscleGroupWhereInput): [MuscleGroupGroupBy!]!
  groupByTimeBox(by: [TimeBoxScalarFieldEnum!]!, having: TimeBoxScalarWhereWithAggregatesInput, orderBy: [TimeBoxOrderByWithAggregationInput!], skip: Int, take: Int, where: TimeBoxWhereInput): [TimeBoxGroupBy!]!
  muscleGroup(where: MuscleGroupWhereUniqueInput!): MuscleGroup
  muscleGroups(cursor: MuscleGroupWhereUniqueInput, distinct: [MuscleGroupScalarFieldEnum!], orderBy: [MuscleGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MuscleGroupWhereInput): [MuscleGroup!]!
  timeBox(where: TimeBoxWhereUniqueInput!): TimeBox
  timeBoxes(cursor: TimeBoxWhereUniqueInput, distinct: [TimeBoxScalarFieldEnum!], orderBy: [TimeBoxOrderByWithRelationInput!], skip: Int, take: Int, where: TimeBoxWhereInput): [TimeBox!]!
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type TimeBox {
  closedAt: DateTime!
  createdAt: DateTime!
  exercisingSession: ExercisingSession!
  exercisingSessionId: Int!
  id: String!
  resting: Boolean!
  updatedAt: DateTime!
}

type TimeBoxAvgAggregate {
  exercisingSessionId: Float
}

input TimeBoxAvgOrderByAggregateInput {
  exercisingSessionId: SortOrder
}

type TimeBoxCountAggregate {
  _all: Int!
  closedAt: Int!
  createdAt: Int!
  exercisingSessionId: Int!
  id: Int!
  resting: Int!
  updatedAt: Int!
}

input TimeBoxCountOrderByAggregateInput {
  closedAt: SortOrder
  exercisingSessionId: SortOrder
  id: SortOrder
  resting: SortOrder
}

input TimeBoxCreateInput {
  closedAt: DateTime!
  exercisingSession: ExercisingSessionCreateNestedOneWithoutTimeBoxInput!
  id: String
  resting: Boolean
}

input TimeBoxCreateManyExercisingSessionInput {
  closedAt: DateTime!
  id: String
  resting: Boolean
}

input TimeBoxCreateManyExercisingSessionInputEnvelope {
  data: [TimeBoxCreateManyExercisingSessionInput!]!
  skipDuplicates: Boolean
}

input TimeBoxCreateManyInput {
  closedAt: DateTime!
  exercisingSessionId: Int!
  id: String
  resting: Boolean
}

input TimeBoxCreateNestedManyWithoutExercisingSessionInput {
  connect: [TimeBoxWhereUniqueInput!]
  connectOrCreate: [TimeBoxCreateOrConnectWithoutExercisingSessionInput!]
  create: [TimeBoxCreateWithoutExercisingSessionInput!]
  createMany: TimeBoxCreateManyExercisingSessionInputEnvelope
}

input TimeBoxCreateOrConnectWithoutExercisingSessionInput {
  create: TimeBoxCreateWithoutExercisingSessionInput!
  where: TimeBoxWhereUniqueInput!
}

input TimeBoxCreateWithoutExercisingSessionInput {
  closedAt: DateTime!
  id: String
  resting: Boolean
}

type TimeBoxGroupBy {
  _avg: TimeBoxAvgAggregate
  _count: TimeBoxCountAggregate
  _max: TimeBoxMaxAggregate
  _min: TimeBoxMinAggregate
  _sum: TimeBoxSumAggregate
  closedAt: DateTime!
  createdAt: DateTime!
  exercisingSessionId: Int!
  id: String!
  resting: Boolean!
  updatedAt: DateTime!
}

input TimeBoxListRelationFilter {
  every: TimeBoxWhereInput
  none: TimeBoxWhereInput
  some: TimeBoxWhereInput
}

type TimeBoxMaxAggregate {
  closedAt: DateTime
  createdAt: DateTime
  exercisingSessionId: Int
  id: String
  resting: Boolean
  updatedAt: DateTime
}

input TimeBoxMaxOrderByAggregateInput {
  closedAt: SortOrder
  exercisingSessionId: SortOrder
  id: SortOrder
  resting: SortOrder
}

type TimeBoxMinAggregate {
  closedAt: DateTime
  createdAt: DateTime
  exercisingSessionId: Int
  id: String
  resting: Boolean
  updatedAt: DateTime
}

input TimeBoxMinOrderByAggregateInput {
  closedAt: SortOrder
  exercisingSessionId: SortOrder
  id: SortOrder
  resting: SortOrder
}

input TimeBoxOrderByRelationAggregateInput {
  _count: SortOrder
}

input TimeBoxOrderByWithAggregationInput {
  _avg: TimeBoxAvgOrderByAggregateInput
  _count: TimeBoxCountOrderByAggregateInput
  _max: TimeBoxMaxOrderByAggregateInput
  _min: TimeBoxMinOrderByAggregateInput
  _sum: TimeBoxSumOrderByAggregateInput
  closedAt: SortOrder
  exercisingSessionId: SortOrder
  id: SortOrder
  resting: SortOrder
}

input TimeBoxOrderByWithRelationInput {
  closedAt: SortOrder
  exercisingSession: ExercisingSessionOrderByWithRelationInput
  exercisingSessionId: SortOrder
  id: SortOrder
  resting: SortOrder
}

enum TimeBoxScalarFieldEnum {
  closedAt
  createdAt
  exercisingSessionId
  id
  resting
  updatedAt
}

input TimeBoxScalarWhereInput {
  AND: [TimeBoxScalarWhereInput!]
  NOT: [TimeBoxScalarWhereInput!]
  OR: [TimeBoxScalarWhereInput!]
  closedAt: DateTimeFilter
  exercisingSessionId: IntFilter
  id: StringFilter
  resting: BoolFilter
}

input TimeBoxScalarWhereWithAggregatesInput {
  AND: [TimeBoxScalarWhereWithAggregatesInput!]
  NOT: [TimeBoxScalarWhereWithAggregatesInput!]
  OR: [TimeBoxScalarWhereWithAggregatesInput!]
  closedAt: DateTimeWithAggregatesFilter
  exercisingSessionId: IntWithAggregatesFilter
  id: StringWithAggregatesFilter
  resting: BoolWithAggregatesFilter
}

type TimeBoxSumAggregate {
  exercisingSessionId: Int
}

input TimeBoxSumOrderByAggregateInput {
  exercisingSessionId: SortOrder
}

input TimeBoxUpdateInput {
  closedAt: DateTimeFieldUpdateOperationsInput
  exercisingSession: ExercisingSessionUpdateOneRequiredWithoutTimeBoxNestedInput
  id: StringFieldUpdateOperationsInput
  resting: BoolFieldUpdateOperationsInput
}

input TimeBoxUpdateManyMutationInput {
  closedAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  resting: BoolFieldUpdateOperationsInput
}

input TimeBoxUpdateManyWithWhereWithoutExercisingSessionInput {
  data: TimeBoxUpdateManyMutationInput!
  where: TimeBoxScalarWhereInput!
}

input TimeBoxUpdateManyWithoutExercisingSessionNestedInput {
  connect: [TimeBoxWhereUniqueInput!]
  connectOrCreate: [TimeBoxCreateOrConnectWithoutExercisingSessionInput!]
  create: [TimeBoxCreateWithoutExercisingSessionInput!]
  createMany: TimeBoxCreateManyExercisingSessionInputEnvelope
  delete: [TimeBoxWhereUniqueInput!]
  deleteMany: [TimeBoxScalarWhereInput!]
  disconnect: [TimeBoxWhereUniqueInput!]
  set: [TimeBoxWhereUniqueInput!]
  update: [TimeBoxUpdateWithWhereUniqueWithoutExercisingSessionInput!]
  updateMany: [TimeBoxUpdateManyWithWhereWithoutExercisingSessionInput!]
  upsert: [TimeBoxUpsertWithWhereUniqueWithoutExercisingSessionInput!]
}

input TimeBoxUpdateWithWhereUniqueWithoutExercisingSessionInput {
  data: TimeBoxUpdateWithoutExercisingSessionInput!
  where: TimeBoxWhereUniqueInput!
}

input TimeBoxUpdateWithoutExercisingSessionInput {
  closedAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  resting: BoolFieldUpdateOperationsInput
}

input TimeBoxUpsertWithWhereUniqueWithoutExercisingSessionInput {
  create: TimeBoxCreateWithoutExercisingSessionInput!
  update: TimeBoxUpdateWithoutExercisingSessionInput!
  where: TimeBoxWhereUniqueInput!
}

input TimeBoxWhereInput {
  AND: [TimeBoxWhereInput!]
  NOT: [TimeBoxWhereInput!]
  OR: [TimeBoxWhereInput!]
  closedAt: DateTimeFilter
  exercisingSession: ExercisingSessionRelationFilter
  exercisingSessionId: IntFilter
  id: StringFilter
  resting: BoolFilter
}

input TimeBoxWhereUniqueInput {
  id: String
}