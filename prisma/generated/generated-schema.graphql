# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateExercise {
  _count: ExerciseCountAggregate
  _max: ExerciseMaxAggregate
  _min: ExerciseMinAggregate
}

type AggregateExercisingSession {
  _count: ExercisingSessionCountAggregate
  _max: ExercisingSessionMaxAggregate
  _min: ExercisingSessionMinAggregate
}

type AggregateMuscleGroup {
  _count: MuscleGroupCountAggregate
  _max: MuscleGroupMaxAggregate
  _min: MuscleGroupMinAggregate
}

type AggregateTimeBox {
  _count: TimeBoxCountAggregate
  _max: TimeBoxMaxAggregate
  _min: TimeBoxMinAggregate
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

enum Difficulty {
  EASY
  HARD
  MEDIUM
}

input EnumDifficultyFieldUpdateOperationsInput {
  set: Difficulty
}

input EnumDifficultyFilter {
  equals: Difficulty
  in: [Difficulty!]
  not: NestedEnumDifficultyFilter
  notIn: [Difficulty!]
}

input EnumDifficultyWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumDifficultyFilter
  _min: NestedEnumDifficultyFilter
  equals: Difficulty
  in: [Difficulty!]
  not: NestedEnumDifficultyWithAggregatesFilter
  notIn: [Difficulty!]
}

input EnumMuscleGroupEnumFieldUpdateOperationsInput {
  set: MuscleGroupEnum
}

input EnumMuscleGroupEnumFilter {
  equals: MuscleGroupEnum
  in: [MuscleGroupEnum!]
  not: NestedEnumMuscleGroupEnumFilter
  notIn: [MuscleGroupEnum!]
}

input EnumMuscleGroupEnumWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumMuscleGroupEnumFilter
  _min: NestedEnumMuscleGroupEnumFilter
  equals: MuscleGroupEnum
  in: [MuscleGroupEnum!]
  not: NestedEnumMuscleGroupEnumWithAggregatesFilter
  notIn: [MuscleGroupEnum!]
}

type Exercise {
  ExercisingSession(cursor: ExercisingSessionWhereUniqueInput, distinct: [ExercisingSessionScalarFieldEnum!], orderBy: [ExercisingSessionOrderByWithRelationInput!], skip: Int, take: Int, where: ExercisingSessionWhereInput): [ExercisingSession!]!
  _count: ExerciseCount
  difficulty: Difficulty!
  id: String!
  muscleGroups(cursor: MuscleGroupWhereUniqueInput, distinct: [MuscleGroupScalarFieldEnum!], orderBy: [MuscleGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MuscleGroupWhereInput): [MuscleGroup!]!
  name: String!
}

type ExerciseCount {
  ExercisingSession: Int!
  muscleGroups: Int!
}

type ExerciseCountAggregate {
  _all: Int!
  difficulty: Int!
  id: Int!
  name: Int!
}

input ExerciseCountOrderByAggregateInput {
  difficulty: SortOrder
  id: SortOrder
  name: SortOrder
}

input ExerciseCreateInput {
  ExercisingSession: ExercisingSessionCreateNestedManyWithoutExerciseInput
  difficulty: Difficulty
  id: String
  muscleGroups: MuscleGroupCreateNestedManyWithoutExercisesInput
  name: String!
}

input ExerciseCreateManyInput {
  difficulty: Difficulty
  id: String
  name: String!
}

input ExerciseCreateNestedManyWithoutMuscleGroupsInput {
  connect: [ExerciseWhereUniqueInput!]
  connectOrCreate: [ExerciseCreateOrConnectWithoutMuscleGroupsInput!]
  create: [ExerciseCreateWithoutMuscleGroupsInput!]
}

input ExerciseCreateNestedOneWithoutExercisingSessionInput {
  connect: ExerciseWhereUniqueInput
  connectOrCreate: ExerciseCreateOrConnectWithoutExercisingSessionInput
  create: ExerciseCreateWithoutExercisingSessionInput
}

input ExerciseCreateOrConnectWithoutExercisingSessionInput {
  create: ExerciseCreateWithoutExercisingSessionInput!
  where: ExerciseWhereUniqueInput!
}

input ExerciseCreateOrConnectWithoutMuscleGroupsInput {
  create: ExerciseCreateWithoutMuscleGroupsInput!
  where: ExerciseWhereUniqueInput!
}

input ExerciseCreateWithoutExercisingSessionInput {
  difficulty: Difficulty
  id: String
  muscleGroups: MuscleGroupCreateNestedManyWithoutExercisesInput
  name: String!
}

input ExerciseCreateWithoutMuscleGroupsInput {
  ExercisingSession: ExercisingSessionCreateNestedManyWithoutExerciseInput
  difficulty: Difficulty
  id: String
  name: String!
}

type ExerciseGroupBy {
  _count: ExerciseCountAggregate
  _max: ExerciseMaxAggregate
  _min: ExerciseMinAggregate
  difficulty: Difficulty!
  id: String!
  name: String!
}

input ExerciseListRelationFilter {
  every: ExerciseWhereInput
  none: ExerciseWhereInput
  some: ExerciseWhereInput
}

type ExerciseMaxAggregate {
  difficulty: Difficulty
  id: String
  name: String
}

input ExerciseMaxOrderByAggregateInput {
  difficulty: SortOrder
  id: SortOrder
  name: SortOrder
}

type ExerciseMinAggregate {
  difficulty: Difficulty
  id: String
  name: String
}

input ExerciseMinOrderByAggregateInput {
  difficulty: SortOrder
  id: SortOrder
  name: SortOrder
}

input ExerciseOrderByRelationAggregateInput {
  _count: SortOrder
}

input ExerciseOrderByWithAggregationInput {
  _count: ExerciseCountOrderByAggregateInput
  _max: ExerciseMaxOrderByAggregateInput
  _min: ExerciseMinOrderByAggregateInput
  difficulty: SortOrder
  id: SortOrder
  name: SortOrder
}

input ExerciseOrderByWithRelationInput {
  ExercisingSession: ExercisingSessionOrderByRelationAggregateInput
  difficulty: SortOrder
  id: SortOrder
  muscleGroups: MuscleGroupOrderByRelationAggregateInput
  name: SortOrder
}

input ExerciseRelationFilter {
  is: ExerciseWhereInput
  isNot: ExerciseWhereInput
}

enum ExerciseScalarFieldEnum {
  difficulty
  id
  name
}

input ExerciseScalarWhereInput {
  AND: [ExerciseScalarWhereInput!]
  NOT: [ExerciseScalarWhereInput!]
  OR: [ExerciseScalarWhereInput!]
  difficulty: EnumDifficultyFilter
  id: StringFilter
  name: StringFilter
}

input ExerciseScalarWhereWithAggregatesInput {
  AND: [ExerciseScalarWhereWithAggregatesInput!]
  NOT: [ExerciseScalarWhereWithAggregatesInput!]
  OR: [ExerciseScalarWhereWithAggregatesInput!]
  difficulty: EnumDifficultyWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input ExerciseUpdateInput {
  ExercisingSession: ExercisingSessionUpdateManyWithoutExerciseNestedInput
  difficulty: EnumDifficultyFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  muscleGroups: MuscleGroupUpdateManyWithoutExercisesNestedInput
  name: StringFieldUpdateOperationsInput
}

input ExerciseUpdateManyMutationInput {
  difficulty: EnumDifficultyFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ExerciseUpdateManyWithWhereWithoutMuscleGroupsInput {
  data: ExerciseUpdateManyMutationInput!
  where: ExerciseScalarWhereInput!
}

input ExerciseUpdateManyWithoutMuscleGroupsNestedInput {
  connect: [ExerciseWhereUniqueInput!]
  connectOrCreate: [ExerciseCreateOrConnectWithoutMuscleGroupsInput!]
  create: [ExerciseCreateWithoutMuscleGroupsInput!]
  delete: [ExerciseWhereUniqueInput!]
  deleteMany: [ExerciseScalarWhereInput!]
  disconnect: [ExerciseWhereUniqueInput!]
  set: [ExerciseWhereUniqueInput!]
  update: [ExerciseUpdateWithWhereUniqueWithoutMuscleGroupsInput!]
  updateMany: [ExerciseUpdateManyWithWhereWithoutMuscleGroupsInput!]
  upsert: [ExerciseUpsertWithWhereUniqueWithoutMuscleGroupsInput!]
}

input ExerciseUpdateOneWithoutExercisingSessionNestedInput {
  connect: ExerciseWhereUniqueInput
  connectOrCreate: ExerciseCreateOrConnectWithoutExercisingSessionInput
  create: ExerciseCreateWithoutExercisingSessionInput
  delete: Boolean
  disconnect: Boolean
  update: ExerciseUpdateWithoutExercisingSessionInput
  upsert: ExerciseUpsertWithoutExercisingSessionInput
}

input ExerciseUpdateWithWhereUniqueWithoutMuscleGroupsInput {
  data: ExerciseUpdateWithoutMuscleGroupsInput!
  where: ExerciseWhereUniqueInput!
}

input ExerciseUpdateWithoutExercisingSessionInput {
  difficulty: EnumDifficultyFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  muscleGroups: MuscleGroupUpdateManyWithoutExercisesNestedInput
  name: StringFieldUpdateOperationsInput
}

input ExerciseUpdateWithoutMuscleGroupsInput {
  ExercisingSession: ExercisingSessionUpdateManyWithoutExerciseNestedInput
  difficulty: EnumDifficultyFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ExerciseUpsertWithWhereUniqueWithoutMuscleGroupsInput {
  create: ExerciseCreateWithoutMuscleGroupsInput!
  update: ExerciseUpdateWithoutMuscleGroupsInput!
  where: ExerciseWhereUniqueInput!
}

input ExerciseUpsertWithoutExercisingSessionInput {
  create: ExerciseCreateWithoutExercisingSessionInput!
  update: ExerciseUpdateWithoutExercisingSessionInput!
}

input ExerciseWhereInput {
  AND: [ExerciseWhereInput!]
  ExercisingSession: ExercisingSessionListRelationFilter
  NOT: [ExerciseWhereInput!]
  OR: [ExerciseWhereInput!]
  difficulty: EnumDifficultyFilter
  id: StringFilter
  muscleGroups: MuscleGroupListRelationFilter
  name: StringFilter
}

input ExerciseWhereUniqueInput {
  id: String
  name: String
}

type ExercisingSession {
  TimeBox(cursor: TimeBoxWhereUniqueInput, distinct: [TimeBoxScalarFieldEnum!], orderBy: [TimeBoxOrderByWithRelationInput!], skip: Int, take: Int, where: TimeBoxWhereInput): [TimeBox!]!
  _count: ExercisingSessionCount
  exercise: Exercise
  exerciseId: String!
  id: String!
  message: String
}

type ExercisingSessionCount {
  TimeBox: Int!
}

type ExercisingSessionCountAggregate {
  _all: Int!
  exerciseId: Int!
  id: Int!
  message: Int!
}

input ExercisingSessionCountOrderByAggregateInput {
  exerciseId: SortOrder
  id: SortOrder
  message: SortOrder
}

input ExercisingSessionCreateInput {
  TimeBox: TimeBoxCreateNestedManyWithoutExercisingSessionInput
  exercise: ExerciseCreateNestedOneWithoutExercisingSessionInput
  id: String
  message: String
}

input ExercisingSessionCreateManyExerciseInput {
  id: String
  message: String
}

input ExercisingSessionCreateManyExerciseInputEnvelope {
  data: [ExercisingSessionCreateManyExerciseInput!]!
  skipDuplicates: Boolean
}

input ExercisingSessionCreateManyInput {
  exerciseId: String!
  id: String
  message: String
}

input ExercisingSessionCreateNestedManyWithoutExerciseInput {
  connect: [ExercisingSessionWhereUniqueInput!]
  connectOrCreate: [ExercisingSessionCreateOrConnectWithoutExerciseInput!]
  create: [ExercisingSessionCreateWithoutExerciseInput!]
  createMany: ExercisingSessionCreateManyExerciseInputEnvelope
}

input ExercisingSessionCreateNestedOneWithoutTimeBoxInput {
  connect: ExercisingSessionWhereUniqueInput
  connectOrCreate: ExercisingSessionCreateOrConnectWithoutTimeBoxInput
  create: ExercisingSessionCreateWithoutTimeBoxInput
}

input ExercisingSessionCreateOrConnectWithoutExerciseInput {
  create: ExercisingSessionCreateWithoutExerciseInput!
  where: ExercisingSessionWhereUniqueInput!
}

input ExercisingSessionCreateOrConnectWithoutTimeBoxInput {
  create: ExercisingSessionCreateWithoutTimeBoxInput!
  where: ExercisingSessionWhereUniqueInput!
}

input ExercisingSessionCreateWithoutExerciseInput {
  TimeBox: TimeBoxCreateNestedManyWithoutExercisingSessionInput
  id: String
  message: String
}

input ExercisingSessionCreateWithoutTimeBoxInput {
  exercise: ExerciseCreateNestedOneWithoutExercisingSessionInput
  id: String
  message: String
}

type ExercisingSessionGroupBy {
  _count: ExercisingSessionCountAggregate
  _max: ExercisingSessionMaxAggregate
  _min: ExercisingSessionMinAggregate
  exerciseId: String!
  id: String!
  message: String
}

input ExercisingSessionListRelationFilter {
  every: ExercisingSessionWhereInput
  none: ExercisingSessionWhereInput
  some: ExercisingSessionWhereInput
}

type ExercisingSessionMaxAggregate {
  exerciseId: String
  id: String
  message: String
}

input ExercisingSessionMaxOrderByAggregateInput {
  exerciseId: SortOrder
  id: SortOrder
  message: SortOrder
}

type ExercisingSessionMinAggregate {
  exerciseId: String
  id: String
  message: String
}

input ExercisingSessionMinOrderByAggregateInput {
  exerciseId: SortOrder
  id: SortOrder
  message: SortOrder
}

input ExercisingSessionOrderByRelationAggregateInput {
  _count: SortOrder
}

input ExercisingSessionOrderByWithAggregationInput {
  _count: ExercisingSessionCountOrderByAggregateInput
  _max: ExercisingSessionMaxOrderByAggregateInput
  _min: ExercisingSessionMinOrderByAggregateInput
  exerciseId: SortOrder
  id: SortOrder
  message: SortOrder
}

input ExercisingSessionOrderByWithRelationInput {
  TimeBox: TimeBoxOrderByRelationAggregateInput
  exercise: ExerciseOrderByWithRelationInput
  exerciseId: SortOrder
  id: SortOrder
  message: SortOrder
}

input ExercisingSessionRelationFilter {
  is: ExercisingSessionWhereInput
  isNot: ExercisingSessionWhereInput
}

enum ExercisingSessionScalarFieldEnum {
  exerciseId
  id
  message
}

input ExercisingSessionScalarWhereInput {
  AND: [ExercisingSessionScalarWhereInput!]
  NOT: [ExercisingSessionScalarWhereInput!]
  OR: [ExercisingSessionScalarWhereInput!]
  exerciseId: StringFilter
  id: StringFilter
  message: StringNullableFilter
}

input ExercisingSessionScalarWhereWithAggregatesInput {
  AND: [ExercisingSessionScalarWhereWithAggregatesInput!]
  NOT: [ExercisingSessionScalarWhereWithAggregatesInput!]
  OR: [ExercisingSessionScalarWhereWithAggregatesInput!]
  exerciseId: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  message: StringNullableWithAggregatesFilter
}

input ExercisingSessionUpdateInput {
  TimeBox: TimeBoxUpdateManyWithoutExercisingSessionNestedInput
  exercise: ExerciseUpdateOneWithoutExercisingSessionNestedInput
  id: StringFieldUpdateOperationsInput
  message: NullableStringFieldUpdateOperationsInput
}

input ExercisingSessionUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  message: NullableStringFieldUpdateOperationsInput
}

input ExercisingSessionUpdateManyWithWhereWithoutExerciseInput {
  data: ExercisingSessionUpdateManyMutationInput!
  where: ExercisingSessionScalarWhereInput!
}

input ExercisingSessionUpdateManyWithoutExerciseNestedInput {
  connect: [ExercisingSessionWhereUniqueInput!]
  connectOrCreate: [ExercisingSessionCreateOrConnectWithoutExerciseInput!]
  create: [ExercisingSessionCreateWithoutExerciseInput!]
  createMany: ExercisingSessionCreateManyExerciseInputEnvelope
  delete: [ExercisingSessionWhereUniqueInput!]
  deleteMany: [ExercisingSessionScalarWhereInput!]
  disconnect: [ExercisingSessionWhereUniqueInput!]
  set: [ExercisingSessionWhereUniqueInput!]
  update: [ExercisingSessionUpdateWithWhereUniqueWithoutExerciseInput!]
  updateMany: [ExercisingSessionUpdateManyWithWhereWithoutExerciseInput!]
  upsert: [ExercisingSessionUpsertWithWhereUniqueWithoutExerciseInput!]
}

input ExercisingSessionUpdateOneRequiredWithoutTimeBoxNestedInput {
  connect: ExercisingSessionWhereUniqueInput
  connectOrCreate: ExercisingSessionCreateOrConnectWithoutTimeBoxInput
  create: ExercisingSessionCreateWithoutTimeBoxInput
  update: ExercisingSessionUpdateWithoutTimeBoxInput
  upsert: ExercisingSessionUpsertWithoutTimeBoxInput
}

input ExercisingSessionUpdateWithWhereUniqueWithoutExerciseInput {
  data: ExercisingSessionUpdateWithoutExerciseInput!
  where: ExercisingSessionWhereUniqueInput!
}

input ExercisingSessionUpdateWithoutExerciseInput {
  TimeBox: TimeBoxUpdateManyWithoutExercisingSessionNestedInput
  id: StringFieldUpdateOperationsInput
  message: NullableStringFieldUpdateOperationsInput
}

input ExercisingSessionUpdateWithoutTimeBoxInput {
  exercise: ExerciseUpdateOneWithoutExercisingSessionNestedInput
  id: StringFieldUpdateOperationsInput
  message: NullableStringFieldUpdateOperationsInput
}

input ExercisingSessionUpsertWithWhereUniqueWithoutExerciseInput {
  create: ExercisingSessionCreateWithoutExerciseInput!
  update: ExercisingSessionUpdateWithoutExerciseInput!
  where: ExercisingSessionWhereUniqueInput!
}

input ExercisingSessionUpsertWithoutTimeBoxInput {
  create: ExercisingSessionCreateWithoutTimeBoxInput!
  update: ExercisingSessionUpdateWithoutTimeBoxInput!
}

input ExercisingSessionWhereInput {
  AND: [ExercisingSessionWhereInput!]
  NOT: [ExercisingSessionWhereInput!]
  OR: [ExercisingSessionWhereInput!]
  TimeBox: TimeBoxListRelationFilter
  exercise: ExerciseRelationFilter
  exerciseId: StringFilter
  id: StringFilter
  message: StringNullableFilter
}

input ExercisingSessionWhereUniqueInput {
  exerciseId: String
  id: String
}

type MuscleGroup {
  _count: MuscleGroupCount
  exercises(cursor: ExerciseWhereUniqueInput, distinct: [ExerciseScalarFieldEnum!], orderBy: [ExerciseOrderByWithRelationInput!], skip: Int, take: Int, where: ExerciseWhereInput): [Exercise!]!
  id: String!
  name: MuscleGroupEnum!
}

type MuscleGroupCount {
  exercises: Int!
}

type MuscleGroupCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
}

input MuscleGroupCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input MuscleGroupCreateInput {
  exercises: ExerciseCreateNestedManyWithoutMuscleGroupsInput
  id: String
  name: MuscleGroupEnum!
}

input MuscleGroupCreateManyInput {
  id: String
  name: MuscleGroupEnum!
}

input MuscleGroupCreateNestedManyWithoutExercisesInput {
  connect: [MuscleGroupWhereUniqueInput!]
  connectOrCreate: [MuscleGroupCreateOrConnectWithoutExercisesInput!]
  create: [MuscleGroupCreateWithoutExercisesInput!]
}

input MuscleGroupCreateOrConnectWithoutExercisesInput {
  create: MuscleGroupCreateWithoutExercisesInput!
  where: MuscleGroupWhereUniqueInput!
}

input MuscleGroupCreateWithoutExercisesInput {
  id: String
  name: MuscleGroupEnum!
}

enum MuscleGroupEnum {
  ABS
  BACK
  CHEST
  CORE
  HIPS
  LEGS
  SHOULDERS
  TRICEPS
}

type MuscleGroupGroupBy {
  _count: MuscleGroupCountAggregate
  _max: MuscleGroupMaxAggregate
  _min: MuscleGroupMinAggregate
  id: String!
  name: MuscleGroupEnum!
}

input MuscleGroupListRelationFilter {
  every: MuscleGroupWhereInput
  none: MuscleGroupWhereInput
  some: MuscleGroupWhereInput
}

type MuscleGroupMaxAggregate {
  id: String
  name: MuscleGroupEnum
}

input MuscleGroupMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type MuscleGroupMinAggregate {
  id: String
  name: MuscleGroupEnum
}

input MuscleGroupMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input MuscleGroupOrderByRelationAggregateInput {
  _count: SortOrder
}

input MuscleGroupOrderByWithAggregationInput {
  _count: MuscleGroupCountOrderByAggregateInput
  _max: MuscleGroupMaxOrderByAggregateInput
  _min: MuscleGroupMinOrderByAggregateInput
  id: SortOrder
  name: SortOrder
}

input MuscleGroupOrderByWithRelationInput {
  exercises: ExerciseOrderByRelationAggregateInput
  id: SortOrder
  name: SortOrder
}

enum MuscleGroupScalarFieldEnum {
  id
  name
}

input MuscleGroupScalarWhereInput {
  AND: [MuscleGroupScalarWhereInput!]
  NOT: [MuscleGroupScalarWhereInput!]
  OR: [MuscleGroupScalarWhereInput!]
  id: StringFilter
  name: EnumMuscleGroupEnumFilter
}

input MuscleGroupScalarWhereWithAggregatesInput {
  AND: [MuscleGroupScalarWhereWithAggregatesInput!]
  NOT: [MuscleGroupScalarWhereWithAggregatesInput!]
  OR: [MuscleGroupScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  name: EnumMuscleGroupEnumWithAggregatesFilter
}

input MuscleGroupUpdateInput {
  exercises: ExerciseUpdateManyWithoutMuscleGroupsNestedInput
  id: StringFieldUpdateOperationsInput
  name: EnumMuscleGroupEnumFieldUpdateOperationsInput
}

input MuscleGroupUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: EnumMuscleGroupEnumFieldUpdateOperationsInput
}

input MuscleGroupUpdateManyWithWhereWithoutExercisesInput {
  data: MuscleGroupUpdateManyMutationInput!
  where: MuscleGroupScalarWhereInput!
}

input MuscleGroupUpdateManyWithoutExercisesNestedInput {
  connect: [MuscleGroupWhereUniqueInput!]
  connectOrCreate: [MuscleGroupCreateOrConnectWithoutExercisesInput!]
  create: [MuscleGroupCreateWithoutExercisesInput!]
  delete: [MuscleGroupWhereUniqueInput!]
  deleteMany: [MuscleGroupScalarWhereInput!]
  disconnect: [MuscleGroupWhereUniqueInput!]
  set: [MuscleGroupWhereUniqueInput!]
  update: [MuscleGroupUpdateWithWhereUniqueWithoutExercisesInput!]
  updateMany: [MuscleGroupUpdateManyWithWhereWithoutExercisesInput!]
  upsert: [MuscleGroupUpsertWithWhereUniqueWithoutExercisesInput!]
}

input MuscleGroupUpdateWithWhereUniqueWithoutExercisesInput {
  data: MuscleGroupUpdateWithoutExercisesInput!
  where: MuscleGroupWhereUniqueInput!
}

input MuscleGroupUpdateWithoutExercisesInput {
  id: StringFieldUpdateOperationsInput
  name: EnumMuscleGroupEnumFieldUpdateOperationsInput
}

input MuscleGroupUpsertWithWhereUniqueWithoutExercisesInput {
  create: MuscleGroupCreateWithoutExercisesInput!
  update: MuscleGroupUpdateWithoutExercisesInput!
  where: MuscleGroupWhereUniqueInput!
}

input MuscleGroupWhereInput {
  AND: [MuscleGroupWhereInput!]
  NOT: [MuscleGroupWhereInput!]
  OR: [MuscleGroupWhereInput!]
  exercises: ExerciseListRelationFilter
  id: StringFilter
  name: EnumMuscleGroupEnumFilter
}

input MuscleGroupWhereUniqueInput {
  id: String
  name: MuscleGroupEnum
}

type Mutation {
  createManyExercise(data: [ExerciseCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyExercisingSession(data: [ExercisingSessionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyMuscleGroup(data: [MuscleGroupCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyTimeBox(data: [TimeBoxCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneExercise(data: ExerciseCreateInput!): Exercise!
  createOneExercisingSession(data: ExercisingSessionCreateInput!): ExercisingSession!
  createOneMuscleGroup(data: MuscleGroupCreateInput!): MuscleGroup!
  createOneTimeBox(data: TimeBoxCreateInput!): TimeBox!
  deleteManyExercise(where: ExerciseWhereInput): AffectedRowsOutput!
  deleteManyExercisingSession(where: ExercisingSessionWhereInput): AffectedRowsOutput!
  deleteManyMuscleGroup(where: MuscleGroupWhereInput): AffectedRowsOutput!
  deleteManyTimeBox(where: TimeBoxWhereInput): AffectedRowsOutput!
  deleteOneExercise(where: ExerciseWhereUniqueInput!): Exercise
  deleteOneExercisingSession(where: ExercisingSessionWhereUniqueInput!): ExercisingSession
  deleteOneMuscleGroup(where: MuscleGroupWhereUniqueInput!): MuscleGroup
  deleteOneTimeBox(where: TimeBoxWhereUniqueInput!): TimeBox
  updateManyExercise(data: ExerciseUpdateManyMutationInput!, where: ExerciseWhereInput): AffectedRowsOutput!
  updateManyExercisingSession(data: ExercisingSessionUpdateManyMutationInput!, where: ExercisingSessionWhereInput): AffectedRowsOutput!
  updateManyMuscleGroup(data: MuscleGroupUpdateManyMutationInput!, where: MuscleGroupWhereInput): AffectedRowsOutput!
  updateManyTimeBox(data: TimeBoxUpdateManyMutationInput!, where: TimeBoxWhereInput): AffectedRowsOutput!
  updateOneExercise(data: ExerciseUpdateInput!, where: ExerciseWhereUniqueInput!): Exercise
  updateOneExercisingSession(data: ExercisingSessionUpdateInput!, where: ExercisingSessionWhereUniqueInput!): ExercisingSession
  updateOneMuscleGroup(data: MuscleGroupUpdateInput!, where: MuscleGroupWhereUniqueInput!): MuscleGroup
  updateOneTimeBox(data: TimeBoxUpdateInput!, where: TimeBoxWhereUniqueInput!): TimeBox
  upsertOneExercise(create: ExerciseCreateInput!, update: ExerciseUpdateInput!, where: ExerciseWhereUniqueInput!): Exercise!
  upsertOneExercisingSession(create: ExercisingSessionCreateInput!, update: ExercisingSessionUpdateInput!, where: ExercisingSessionWhereUniqueInput!): ExercisingSession!
  upsertOneMuscleGroup(create: MuscleGroupCreateInput!, update: MuscleGroupUpdateInput!, where: MuscleGroupWhereUniqueInput!): MuscleGroup!
  upsertOneTimeBox(create: TimeBoxCreateInput!, update: TimeBoxUpdateInput!, where: TimeBoxWhereUniqueInput!): TimeBox!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumDifficultyFilter {
  equals: Difficulty
  in: [Difficulty!]
  not: NestedEnumDifficultyFilter
  notIn: [Difficulty!]
}

input NestedEnumDifficultyWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumDifficultyFilter
  _min: NestedEnumDifficultyFilter
  equals: Difficulty
  in: [Difficulty!]
  not: NestedEnumDifficultyWithAggregatesFilter
  notIn: [Difficulty!]
}

input NestedEnumMuscleGroupEnumFilter {
  equals: MuscleGroupEnum
  in: [MuscleGroupEnum!]
  not: NestedEnumMuscleGroupEnumFilter
  notIn: [MuscleGroupEnum!]
}

input NestedEnumMuscleGroupEnumWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumMuscleGroupEnumFilter
  _min: NestedEnumMuscleGroupEnumFilter
  equals: MuscleGroupEnum
  in: [MuscleGroupEnum!]
  not: NestedEnumMuscleGroupEnumWithAggregatesFilter
  notIn: [MuscleGroupEnum!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  aggregateExercise(cursor: ExerciseWhereUniqueInput, orderBy: [ExerciseOrderByWithRelationInput!], skip: Int, take: Int, where: ExerciseWhereInput): AggregateExercise!
  aggregateExercisingSession(cursor: ExercisingSessionWhereUniqueInput, orderBy: [ExercisingSessionOrderByWithRelationInput!], skip: Int, take: Int, where: ExercisingSessionWhereInput): AggregateExercisingSession!
  aggregateMuscleGroup(cursor: MuscleGroupWhereUniqueInput, orderBy: [MuscleGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MuscleGroupWhereInput): AggregateMuscleGroup!
  aggregateTimeBox(cursor: TimeBoxWhereUniqueInput, orderBy: [TimeBoxOrderByWithRelationInput!], skip: Int, take: Int, where: TimeBoxWhereInput): AggregateTimeBox!
  exercise(where: ExerciseWhereUniqueInput!): Exercise
  exercises(cursor: ExerciseWhereUniqueInput, distinct: [ExerciseScalarFieldEnum!], orderBy: [ExerciseOrderByWithRelationInput!], skip: Int, take: Int, where: ExerciseWhereInput): [Exercise!]!
  exercisingSession(where: ExercisingSessionWhereUniqueInput!): ExercisingSession
  exercisingSessions(cursor: ExercisingSessionWhereUniqueInput, distinct: [ExercisingSessionScalarFieldEnum!], orderBy: [ExercisingSessionOrderByWithRelationInput!], skip: Int, take: Int, where: ExercisingSessionWhereInput): [ExercisingSession!]!
  findFirstExercise(cursor: ExerciseWhereUniqueInput, distinct: [ExerciseScalarFieldEnum!], orderBy: [ExerciseOrderByWithRelationInput!], skip: Int, take: Int, where: ExerciseWhereInput): Exercise
  findFirstExerciseOrThrow(cursor: ExerciseWhereUniqueInput, distinct: [ExerciseScalarFieldEnum!], orderBy: [ExerciseOrderByWithRelationInput!], skip: Int, take: Int, where: ExerciseWhereInput): Exercise
  findFirstExercisingSession(cursor: ExercisingSessionWhereUniqueInput, distinct: [ExercisingSessionScalarFieldEnum!], orderBy: [ExercisingSessionOrderByWithRelationInput!], skip: Int, take: Int, where: ExercisingSessionWhereInput): ExercisingSession
  findFirstExercisingSessionOrThrow(cursor: ExercisingSessionWhereUniqueInput, distinct: [ExercisingSessionScalarFieldEnum!], orderBy: [ExercisingSessionOrderByWithRelationInput!], skip: Int, take: Int, where: ExercisingSessionWhereInput): ExercisingSession
  findFirstMuscleGroup(cursor: MuscleGroupWhereUniqueInput, distinct: [MuscleGroupScalarFieldEnum!], orderBy: [MuscleGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MuscleGroupWhereInput): MuscleGroup
  findFirstMuscleGroupOrThrow(cursor: MuscleGroupWhereUniqueInput, distinct: [MuscleGroupScalarFieldEnum!], orderBy: [MuscleGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MuscleGroupWhereInput): MuscleGroup
  findFirstTimeBox(cursor: TimeBoxWhereUniqueInput, distinct: [TimeBoxScalarFieldEnum!], orderBy: [TimeBoxOrderByWithRelationInput!], skip: Int, take: Int, where: TimeBoxWhereInput): TimeBox
  findFirstTimeBoxOrThrow(cursor: TimeBoxWhereUniqueInput, distinct: [TimeBoxScalarFieldEnum!], orderBy: [TimeBoxOrderByWithRelationInput!], skip: Int, take: Int, where: TimeBoxWhereInput): TimeBox
  getExercise(where: ExerciseWhereUniqueInput!): Exercise
  getExercisingSession(where: ExercisingSessionWhereUniqueInput!): ExercisingSession
  getMuscleGroup(where: MuscleGroupWhereUniqueInput!): MuscleGroup
  getTimeBox(where: TimeBoxWhereUniqueInput!): TimeBox
  groupByExercise(by: [ExerciseScalarFieldEnum!]!, having: ExerciseScalarWhereWithAggregatesInput, orderBy: [ExerciseOrderByWithAggregationInput!], skip: Int, take: Int, where: ExerciseWhereInput): [ExerciseGroupBy!]!
  groupByExercisingSession(by: [ExercisingSessionScalarFieldEnum!]!, having: ExercisingSessionScalarWhereWithAggregatesInput, orderBy: [ExercisingSessionOrderByWithAggregationInput!], skip: Int, take: Int, where: ExercisingSessionWhereInput): [ExercisingSessionGroupBy!]!
  groupByMuscleGroup(by: [MuscleGroupScalarFieldEnum!]!, having: MuscleGroupScalarWhereWithAggregatesInput, orderBy: [MuscleGroupOrderByWithAggregationInput!], skip: Int, take: Int, where: MuscleGroupWhereInput): [MuscleGroupGroupBy!]!
  groupByTimeBox(by: [TimeBoxScalarFieldEnum!]!, having: TimeBoxScalarWhereWithAggregatesInput, orderBy: [TimeBoxOrderByWithAggregationInput!], skip: Int, take: Int, where: TimeBoxWhereInput): [TimeBoxGroupBy!]!
  muscleGroup(where: MuscleGroupWhereUniqueInput!): MuscleGroup
  muscleGroups(cursor: MuscleGroupWhereUniqueInput, distinct: [MuscleGroupScalarFieldEnum!], orderBy: [MuscleGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MuscleGroupWhereInput): [MuscleGroup!]!
  timeBox(where: TimeBoxWhereUniqueInput!): TimeBox
  timeBoxes(cursor: TimeBoxWhereUniqueInput, distinct: [TimeBoxScalarFieldEnum!], orderBy: [TimeBoxOrderByWithRelationInput!], skip: Int, take: Int, where: TimeBoxWhereInput): [TimeBox!]!
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type TimeBox {
  closedAt: DateTime!
  createdAt: DateTime!
  exercisingSession: ExercisingSession!
  exercisingSessionId: String!
  id: String!
  resting: Boolean!
  updatedAt: DateTime!
}

type TimeBoxCountAggregate {
  _all: Int!
  closedAt: Int!
  createdAt: Int!
  exercisingSessionId: Int!
  id: Int!
  resting: Int!
  updatedAt: Int!
}

input TimeBoxCountOrderByAggregateInput {
  closedAt: SortOrder
  createdAt: SortOrder
  exercisingSessionId: SortOrder
  id: SortOrder
  resting: SortOrder
}

input TimeBoxCreateInput {
  closedAt: DateTime!
  createdAt: DateTime
  exercisingSession: ExercisingSessionCreateNestedOneWithoutTimeBoxInput!
  id: String
  resting: Boolean
}

input TimeBoxCreateManyExercisingSessionInput {
  closedAt: DateTime!
  createdAt: DateTime
  id: String
  resting: Boolean
}

input TimeBoxCreateManyExercisingSessionInputEnvelope {
  data: [TimeBoxCreateManyExercisingSessionInput!]!
  skipDuplicates: Boolean
}

input TimeBoxCreateManyInput {
  closedAt: DateTime!
  createdAt: DateTime
  exercisingSessionId: String!
  id: String
  resting: Boolean
}

input TimeBoxCreateNestedManyWithoutExercisingSessionInput {
  connect: [TimeBoxWhereUniqueInput!]
  connectOrCreate: [TimeBoxCreateOrConnectWithoutExercisingSessionInput!]
  create: [TimeBoxCreateWithoutExercisingSessionInput!]
  createMany: TimeBoxCreateManyExercisingSessionInputEnvelope
}

input TimeBoxCreateOrConnectWithoutExercisingSessionInput {
  create: TimeBoxCreateWithoutExercisingSessionInput!
  where: TimeBoxWhereUniqueInput!
}

input TimeBoxCreateWithoutExercisingSessionInput {
  closedAt: DateTime!
  createdAt: DateTime
  id: String
  resting: Boolean
}

type TimeBoxGroupBy {
  _count: TimeBoxCountAggregate
  _max: TimeBoxMaxAggregate
  _min: TimeBoxMinAggregate
  closedAt: DateTime!
  createdAt: DateTime!
  exercisingSessionId: String!
  id: String!
  resting: Boolean!
  updatedAt: DateTime!
}

input TimeBoxListRelationFilter {
  every: TimeBoxWhereInput
  none: TimeBoxWhereInput
  some: TimeBoxWhereInput
}

type TimeBoxMaxAggregate {
  closedAt: DateTime
  createdAt: DateTime
  exercisingSessionId: String
  id: String
  resting: Boolean
  updatedAt: DateTime
}

input TimeBoxMaxOrderByAggregateInput {
  closedAt: SortOrder
  createdAt: SortOrder
  exercisingSessionId: SortOrder
  id: SortOrder
  resting: SortOrder
}

type TimeBoxMinAggregate {
  closedAt: DateTime
  createdAt: DateTime
  exercisingSessionId: String
  id: String
  resting: Boolean
  updatedAt: DateTime
}

input TimeBoxMinOrderByAggregateInput {
  closedAt: SortOrder
  createdAt: SortOrder
  exercisingSessionId: SortOrder
  id: SortOrder
  resting: SortOrder
}

input TimeBoxOrderByRelationAggregateInput {
  _count: SortOrder
}

input TimeBoxOrderByWithAggregationInput {
  _count: TimeBoxCountOrderByAggregateInput
  _max: TimeBoxMaxOrderByAggregateInput
  _min: TimeBoxMinOrderByAggregateInput
  closedAt: SortOrder
  createdAt: SortOrder
  exercisingSessionId: SortOrder
  id: SortOrder
  resting: SortOrder
}

input TimeBoxOrderByWithRelationInput {
  closedAt: SortOrder
  createdAt: SortOrder
  exercisingSession: ExercisingSessionOrderByWithRelationInput
  exercisingSessionId: SortOrder
  id: SortOrder
  resting: SortOrder
}

enum TimeBoxScalarFieldEnum {
  closedAt
  createdAt
  exercisingSessionId
  id
  resting
  updatedAt
}

input TimeBoxScalarWhereInput {
  AND: [TimeBoxScalarWhereInput!]
  NOT: [TimeBoxScalarWhereInput!]
  OR: [TimeBoxScalarWhereInput!]
  closedAt: DateTimeFilter
  createdAt: DateTimeFilter
  exercisingSessionId: StringFilter
  id: StringFilter
  resting: BoolFilter
}

input TimeBoxScalarWhereWithAggregatesInput {
  AND: [TimeBoxScalarWhereWithAggregatesInput!]
  NOT: [TimeBoxScalarWhereWithAggregatesInput!]
  OR: [TimeBoxScalarWhereWithAggregatesInput!]
  closedAt: DateTimeWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  exercisingSessionId: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  resting: BoolWithAggregatesFilter
}

input TimeBoxUpdateInput {
  closedAt: DateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  exercisingSession: ExercisingSessionUpdateOneRequiredWithoutTimeBoxNestedInput
  id: StringFieldUpdateOperationsInput
  resting: BoolFieldUpdateOperationsInput
}

input TimeBoxUpdateManyMutationInput {
  closedAt: DateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  resting: BoolFieldUpdateOperationsInput
}

input TimeBoxUpdateManyWithWhereWithoutExercisingSessionInput {
  data: TimeBoxUpdateManyMutationInput!
  where: TimeBoxScalarWhereInput!
}

input TimeBoxUpdateManyWithoutExercisingSessionNestedInput {
  connect: [TimeBoxWhereUniqueInput!]
  connectOrCreate: [TimeBoxCreateOrConnectWithoutExercisingSessionInput!]
  create: [TimeBoxCreateWithoutExercisingSessionInput!]
  createMany: TimeBoxCreateManyExercisingSessionInputEnvelope
  delete: [TimeBoxWhereUniqueInput!]
  deleteMany: [TimeBoxScalarWhereInput!]
  disconnect: [TimeBoxWhereUniqueInput!]
  set: [TimeBoxWhereUniqueInput!]
  update: [TimeBoxUpdateWithWhereUniqueWithoutExercisingSessionInput!]
  updateMany: [TimeBoxUpdateManyWithWhereWithoutExercisingSessionInput!]
  upsert: [TimeBoxUpsertWithWhereUniqueWithoutExercisingSessionInput!]
}

input TimeBoxUpdateWithWhereUniqueWithoutExercisingSessionInput {
  data: TimeBoxUpdateWithoutExercisingSessionInput!
  where: TimeBoxWhereUniqueInput!
}

input TimeBoxUpdateWithoutExercisingSessionInput {
  closedAt: DateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  resting: BoolFieldUpdateOperationsInput
}

input TimeBoxUpsertWithWhereUniqueWithoutExercisingSessionInput {
  create: TimeBoxCreateWithoutExercisingSessionInput!
  update: TimeBoxUpdateWithoutExercisingSessionInput!
  where: TimeBoxWhereUniqueInput!
}

input TimeBoxWhereInput {
  AND: [TimeBoxWhereInput!]
  NOT: [TimeBoxWhereInput!]
  OR: [TimeBoxWhereInput!]
  closedAt: DateTimeFilter
  createdAt: DateTimeFilter
  exercisingSession: ExercisingSessionRelationFilter
  exercisingSessionId: StringFilter
  id: StringFilter
  resting: BoolFilter
}

input TimeBoxWhereUniqueInput {
  id: String
}